name: Run Whisper Sample App

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'samples/WhisperDemo/**'
      - '.github/workflows/whisper-sample-app.yml'
      - 'scripts/download-whisper-model.*'
      - 'scripts/download-sample-audio.*'
  workflow_dispatch:

permissions:
  pull-requests: write
  issues: write

env:
  OPENVINO_VERSION: "2025.3.0.0.dev20250805"

jobs:
  whisper-demo:
    name: Whisper Demo - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            runtime: linux-x64
          - os: windows-latest
            runtime: win-x64

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Install Visual C++ Redistributables
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "Installing Visual C++ Redistributables..."
        
        # Download and install VC++ redistributables
        $vcRedistUrl = "https://aka.ms/vs/17/release/vc_redist.x64.exe"
        $vcRedistPath = "vc_redist.x64.exe"
        
        try {
          Invoke-WebRequest -Uri $vcRedistUrl -OutFile $vcRedistPath
          
          # Install silently
          Start-Process -FilePath $vcRedistPath -ArgumentList "/install", "/quiet", "/norestart" -Wait
          
          Write-Host "✓ Visual C++ Redistributables installed successfully"
        } catch {
          Write-Host "Warning: Failed to install Visual C++ Redistributables: $($_.Exception.Message)"
          Write-Host "This may cause native library loading issues"
        } finally {
          if (Test-Path $vcRedistPath) {
            Remove-Item $vcRedistPath -Force
          }
        }

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Cache Whisper Model
      uses: actions/cache@v4
      with:
        path: ./Models/whisper-tiny-int4-ov-npu
        key: whisper-model-v1
        restore-keys: |
          whisper-model-

    - name: Cache Sample Audio
      uses: actions/cache@v4
      with:
        path: ./samples/audio
        key: sample-audio-v1
        restore-keys: |
          sample-audio-

    - name: Restore dependencies
      run: dotnet restore OpenVINO.NET.sln

    - name: Cache OpenVINO Runtime (Windows)
      if: matrix.os == 'windows-latest'
      id: cache-openvino-windows
      uses: actions/cache@v4
      with:
        path: build/native/runtimes/win-x64/native
        key: openvino-runtime-windows-${{ env.OPENVINO_VERSION }}

    - name: Cache OpenVINO Runtime (Linux)
      if: matrix.os == 'ubuntu-latest'
      id: cache-openvino-linux
      uses: actions/cache@v4
      with:
        path: build/native/runtimes/linux-x64/native
        key: openvino-runtime-linux-${{ env.OPENVINO_VERSION }}

    - name: Download OpenVINO Runtime (Windows)
      if: matrix.os == 'windows-latest' && steps.cache-openvino-windows.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        ./scripts/download-openvino-runtime.ps1 -Version "${{ env.OPENVINO_VERSION }}" -OutputPath "build/native"
        
    - name: Set OPENVINO_RUNTIME_PATH for Windows
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        $runtimePath = "$(Get-Location)/build/native/runtimes/win-x64/native"
        "OPENVINO_RUNTIME_PATH=$runtimePath" | Out-File -FilePath $env:GITHUB_ENV -Append
        Write-Host "Set OPENVINO_RUNTIME_PATH to: $runtimePath"

    - name: Download OpenVINO Runtime (Linux)
      if: matrix.os == 'ubuntu-latest' && steps.cache-openvino-linux.outputs.cache-hit != 'true'
      run: |
        chmod +x scripts/download-openvino-runtime.sh
        ./scripts/download-openvino-runtime.sh "${{ env.OPENVINO_VERSION }}" "build/native" "24"
        
    - name: Set OPENVINO_RUNTIME_PATH for Linux
      if: matrix.os == 'ubuntu-latest'
      run: |
        RUNTIME_PATH="$(pwd)/build/native/runtimes/linux-x64/native"
        echo "OPENVINO_RUNTIME_PATH=$RUNTIME_PATH" >> $GITHUB_ENV
        echo "Set OPENVINO_RUNTIME_PATH to: $RUNTIME_PATH"

    - name: Verify OpenVINO Runtime Installation (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "Verifying OpenVINO Runtime Installation..."
        Write-Host "========================================"
        
        $runtimePath = "build/native/runtimes/win-x64/native"
        
        if (Test-Path $runtimePath) {
          Write-Host "✓ Runtime directory exists: $runtimePath"
          
          # List all files in the runtime directory
          Write-Host ""
          Write-Host "Files in runtime directory:"
          Get-ChildItem -Path $runtimePath -Recurse | Format-Table Name, Length, LastWriteTime
          
          # Check for specific required DLLs
          $requiredDlls = @("openvino_genai_c.dll", "openvino_c.dll")
          $missingDlls = @()
          
          foreach ($dll in $requiredDlls) {
            $found = Get-ChildItem -Path $runtimePath -Filter $dll -Recurse -ErrorAction SilentlyContinue
            if ($found) {
              Write-Host "✓ Found required DLL: $dll at $($found[0].FullName)"
            } else {
              Write-Host "✗ Missing required DLL: $dll"
              $missingDlls += $dll
            }
          }
          
          if ($missingDlls.Count -eq 0) {
            Write-Host ""
            Write-Host "✓ All required DLLs are present"
          } else {
            Write-Host ""
            Write-Host "❌ Missing DLLs: $($missingDlls -join ', ')"
            Write-Host "This will cause runtime failures"
            exit 1
          }
        } else {
          Write-Host "❌ Runtime directory not found: $runtimePath"
          exit 1
        }

    - name: Verify OpenVINO Runtime Installation (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        echo "Verifying OpenVINO Runtime Installation..."
        echo "========================================"
        
        RUNTIME_PATH="build/native/runtimes/linux-x64/native"
        
        if [ -d "$RUNTIME_PATH" ]; then
          echo "✓ Runtime directory exists: $RUNTIME_PATH"
          
          # List all files in the runtime directory
          echo ""
          echo "Files in runtime directory:"
          ls -la "$RUNTIME_PATH"
          
          # Check for specific required libraries (both versioned and unversioned)
          REQUIRED_LIBS=("libopenvino_genai_c.so" "libopenvino_c.so")
          MISSING_LIBS=()
          
          for lib in "${REQUIRED_LIBS[@]}"; do
            # Check for unversioned symlink (what .NET expects)
            if [ -f "$RUNTIME_PATH/$lib" ] || [ -L "$RUNTIME_PATH/$lib" ]; then
              if [ -L "$RUNTIME_PATH/$lib" ]; then
                TARGET=$(readlink "$RUNTIME_PATH/$lib")
                echo "✓ Found required library symlink: $lib → $TARGET"
              else
                echo "✓ Found required library: $lib"
              fi
            # Check for versioned library files
            elif find "$RUNTIME_PATH" -name "$lib*" -type f | grep -q .; then
              FOUND_LIB=$(find "$RUNTIME_PATH" -name "$lib*" -type f | head -1)
              echo "⚠ Found versioned library: $FOUND_LIB (but missing unversioned symlink $lib)"
              MISSING_LIBS+=("$lib")
            else
              echo "✗ Missing required library: $lib"
              MISSING_LIBS+=("$lib")
            fi
          done
          
          if [ ${#MISSING_LIBS[@]} -eq 0 ]; then
            echo ""
            echo "✓ All required libraries are present"
          else
            echo ""
            echo "❌ Missing libraries: ${MISSING_LIBS[*]}"
            echo "This will cause runtime failures"
            exit 1
          fi
        else
          echo "❌ Runtime directory not found: $RUNTIME_PATH"
          exit 1
        fi

    - name: Download Whisper Model (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        ./scripts/download-whisper-model.ps1

    - name: Download Whisper Model (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        chmod +x scripts/download-whisper-model.sh
        ./scripts/download-whisper-model.sh

    - name: Download Sample Audio (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        if (Test-Path ./scripts/download-sample-audio.ps1) {
          ./scripts/download-sample-audio.ps1
        } else {
          Write-Host "Creating sample audio directory..."
          New-Item -ItemType Directory -Path "samples/audio" -Force
          
          # Download audio files from Hugging Face FluidInference/audio dataset
          $audioFiles = @(
            @{
              url = "https://huggingface.co/datasets/FluidInference/audio/resolve/main/glm.wav"
              filename = "glm.wav"
            },
            @{
              url = "https://huggingface.co/datasets/FluidInference/audio/resolve/main/startup.wav"
              filename = "startup.wav"
            }
          )
          
          foreach ($audio in $audioFiles) {
            $audioPath = "samples/audio/$($audio.filename)"
            Write-Host "Downloading $($audio.filename)..."
            
            try {
              Invoke-WebRequest -Uri $audio.url -OutFile $audioPath -UseBasicParsing
              Write-Host "✓ Downloaded $($audio.filename) to: $audioPath"
            } catch {
              Write-Host "Warning: Failed to download $($audio.filename): $($_.Exception.Message)"
              # Create a dummy file for testing
              New-Item -ItemType File -Path $audioPath -Force
            }
          }
        }

    - name: Download Sample Audio (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        if [ -f ./scripts/download-sample-audio.sh ]; then
          chmod +x ./scripts/download-sample-audio.sh
          ./scripts/download-sample-audio.sh
        else
          echo "Creating sample audio directory..."
          mkdir -p samples/audio
          
          # Download audio files from Hugging Face FluidInference/audio dataset
          declare -a AUDIO_FILES=(
            "glm.wav:https://huggingface.co/datasets/FluidInference/audio/resolve/main/glm.wav"
            "startup.wav:https://huggingface.co/datasets/FluidInference/audio/resolve/main/startup.wav"
          )
          
          for audio_entry in "${AUDIO_FILES[@]}"; do
            IFS=':' read -r filename url <<< "$audio_entry"
            AUDIO_PATH="samples/audio/$filename"
            echo "Downloading $filename..."
            
            if curl -L -o "$AUDIO_PATH" "$url"; then
              echo "✓ Downloaded $filename to: $AUDIO_PATH"
            else
              echo "Warning: Failed to download $filename"
              # Create a dummy file for testing
              touch "$AUDIO_PATH"
            fi
          done
        fi

    - name: Build solution
      run: dotnet build OpenVINO.NET.sln --configuration Release

    - name: Setup Environment for OpenVINO (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        # Set the OpenVINO runtime path - this is where the DLLs are actually located
        $runtimePath = "$(Get-Location)/build/native/runtimes/win-x64/native"
        
        # Set OPENVINO_RUNTIME_PATH environment variable (prioritized by NativeLibraryLoader)
        "OPENVINO_RUNTIME_PATH=$runtimePath" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Also add to PATH for compatibility
        $currentPath = $env:PATH
        $newPath = "$runtimePath;$currentPath"
        "PATH=$newPath" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        Write-Host "Set OPENVINO_RUNTIME_PATH to: $runtimePath"
        Write-Host "Added OpenVINO runtime to PATH: $runtimePath"
        Write-Host "Verifying PATH update..."
        Write-Host "PATH now contains:"
        ($newPath -split ';') | ForEach-Object { Write-Host "  $_" }

    - name: Setup Environment for OpenVINO (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        # Set the OpenVINO runtime path - this is where the libraries are actually located
        RUNTIME_PATH="$(pwd)/build/native/runtimes/linux-x64/native"
        
        # Set OPENVINO_RUNTIME_PATH environment variable (prioritized by NativeLibraryLoader)
        echo "OPENVINO_RUNTIME_PATH=$RUNTIME_PATH" >> $GITHUB_ENV
        
        # Set LD_LIBRARY_PATH for runtime linking
        echo "LD_LIBRARY_PATH=$RUNTIME_PATH:$LD_LIBRARY_PATH" >> $GITHUB_ENV
        
        echo "Set OPENVINO_RUNTIME_PATH to: $RUNTIME_PATH"
        echo "Set LD_LIBRARY_PATH to: $RUNTIME_PATH:$LD_LIBRARY_PATH"

    - name: Run WhisperDemo (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      timeout-minutes: 5
      run: |
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        
        # Get absolute paths
        $modelPath = "$(Get-Location)\Models\whisper-tiny-int4-ov-npu"
        $audioDir = "$(Get-Location)\samples\audio"
        
        # Set environment variable for model path
        $env:WHISPER_MODEL_PATH = $modelPath
        
        Write-Host "Model Path: $modelPath"
        Write-Host "Audio Dir: $audioDir"
        Write-Host "Checking if model exists..."
        if (Test-Path $modelPath) {
          Write-Host "Model directory found"
          Get-ChildItem $modelPath | Select-Object Name | Out-String | Write-Host
        } else {
          Write-Host "WARNING: Model directory not found at $modelPath"
        }
        
        # Navigate to WhisperDemo for binary output
        Set-Location samples\WhisperDemo
        
        $output = @()
        $output += "# Whisper Sample App Results - Windows x64"
        $output += ""
        $output += "**Generated:** $timestamp"
        $output += "**Platform:** win-x64"
        $output += "**Model:** whisper-tiny-int4-ov-npu"
        $output += ""
        
        # Check if we have audio files
        $audioFiles = Get-ChildItem -Path $audioDir -Filter "*.wav" -ErrorAction SilentlyContinue
        
        if ($audioFiles) {
          $output += "## Transcription Results"
          $output += ""
          Write-Host "Found $($audioFiles.Count) audio files"
          
          foreach ($audio in $audioFiles) {
            Write-Host "Processing: $($audio.Name)"
            $output += "### $($audio.Name)"
            $output += "``````"
            
            try {
              # Use Start-Process with timeout to prevent hanging
              $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release", "--", "--audio", "`"$($audio.FullName)`"", "--device", "CPU" -NoNewWindow -Wait -PassThru -RedirectStandardOutput "temp_output.txt" -RedirectStandardError "temp_error.txt"
              
              # Wait max 30 seconds per file
              if (!$process.WaitForExit(30000)) {
                $process.Kill()
                $output += "Error: Process timed out after 30 seconds"
              } else {
                $stdout = Get-Content "temp_output.txt" -Raw -ErrorAction SilentlyContinue
                $stderr = Get-Content "temp_error.txt" -Raw -ErrorAction SilentlyContinue
                if ($stdout) { $output += $stdout }
                if ($stderr) { $output += "STDERR: $stderr" }
              }
              
              Remove-Item "temp_output.txt", "temp_error.txt" -ErrorAction SilentlyContinue
            } catch {
              $output += "Error: $($_.Exception.Message)"
            }
            
            $output += "``````"
            $output += ""
          }
        } else {
          $output += "## Test Run"
          $output += "``````"
          Write-Host "No audio files found, running with generated test audio"
          
          # Run with generated test audio and timeout
          try {
            $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release", "--", "--device", "CPU", "--workflow" -NoNewWindow -Wait -PassThru -RedirectStandardOutput "temp_output.txt" -RedirectStandardError "temp_error.txt"
            
            if (!$process.WaitForExit(30000)) {
              $process.Kill()
              $output += "Error: Process timed out after 30 seconds"
            } else {
              $stdout = Get-Content "temp_output.txt" -Raw -ErrorAction SilentlyContinue
              $stderr = Get-Content "temp_error.txt" -Raw -ErrorAction SilentlyContinue
              if ($stdout) { $output += $stdout }
              if ($stderr) { $output += "STDERR: $stderr" }
            }
            
            Remove-Item "temp_output.txt", "temp_error.txt" -ErrorAction SilentlyContinue
          } catch {
            $output += "Error: $($_.Exception.Message)"
          }
          
          $output += "``````"
        }
        
        # Save and display output
        $output | Out-File -FilePath "whisper-results.md" -Encoding UTF8
        Write-Host "`n=== Results ===`n"
        Get-Content "whisper-results.md" | Write-Host
        Write-Host "`n=== End Results ===`n"

    - name: Run WhisperDemo (Linux)
      if: matrix.os == 'ubuntu-latest'
      timeout-minutes: 5
      run: |
        TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
        
        # Get absolute paths
        MODEL_PATH="$(pwd)/Models/whisper-tiny-int4-ov-npu"
        AUDIO_DIR="$(pwd)/samples/audio"
        
        echo "Model Path: $MODEL_PATH"
        echo "Audio Dir: $AUDIO_DIR"
        echo "OPENVINO_RUNTIME_PATH: $OPENVINO_RUNTIME_PATH"
        echo "LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
        echo "Checking if model exists..."
        if [ -d "$MODEL_PATH" ]; then
          echo "Model directory found"
          ls -la "$MODEL_PATH" | head -20
        else
          echo "WARNING: Model directory not found at $MODEL_PATH"
        fi
        
        # Navigate to WhisperDemo for binary output
        cd samples/WhisperDemo
        
        {
          echo "# Whisper Sample App Results - Linux x64"
          echo ""
          echo "**Generated:** $TIMESTAMP"
          echo "**Platform:** linux-x64"
          echo "**Model:** whisper-tiny-int4-ov-npu"
          echo ""
          
          # Check if we have audio files
          if ls "$AUDIO_DIR"/*.wav 2>/dev/null; then
            echo "## Transcription Results"
            echo ""
            
            AUDIO_COUNT=$(ls -1 "$AUDIO_DIR"/*.wav 2>/dev/null | wc -l)
            echo "Found $AUDIO_COUNT audio files" >&2
            
            for audio in "$AUDIO_DIR"/*.wav; do
              echo "Processing: $(basename "$audio")" >&2
              echo "### $(basename "$audio")"
              echo '```'
              # Use timeout to prevent hanging
              WHISPER_MODEL_PATH="$MODEL_PATH" timeout 30 dotnet run --configuration Release -- --audio "$audio" --device CPU 2>&1 || {
                EXIT_CODE=$?
                if [ $EXIT_CODE -eq 124 ]; then
                  echo "Error: Process timed out after 30 seconds"
                else
                  echo "Error running transcription (exit code: $EXIT_CODE)"
                fi
              }
              echo '```'
              echo ""
            done
          else
            echo "## Test Run"
            echo '```'
            echo "No audio files found, running with generated test audio" >&2
            # Run with generated test audio and workflow flag
            WHISPER_MODEL_PATH="$MODEL_PATH" timeout 30 dotnet run --configuration Release -- --device CPU --workflow 2>&1 || {
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 124 ]; then
                echo "Error: Process timed out after 30 seconds"
              else
                echo "Error running demo (exit code: $EXIT_CODE)"
              fi
            }
            echo '```'
          fi
        } > whisper-results.md
        
        echo ""
        echo "=== Results ==="
        cat whisper-results.md
        echo "=== End Results ==="
        echo ""

    - name: Upload Results
      uses: actions/upload-artifact@v4
      with:
        name: whisper-results-${{ matrix.runtime }}
        path: ./samples/WhisperDemo/whisper-results.md

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const resultsPath = './samples/WhisperDemo/whisper-results.md';
          
          if (fs.existsSync(resultsPath)) {
            const results = fs.readFileSync(resultsPath, 'utf8');
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const platform = '${{ matrix.runtime }}';
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes(`Whisper Sample App Results - ${platform === 'win-x64' ? 'Windows' : 'Linux'} x64`)
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: results
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: results
              });
            }
          }