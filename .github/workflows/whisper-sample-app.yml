name: Run Whisper Sample App

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'samples/WhisperDemo/**'
      - '.github/workflows/whisper-sample-app.yml'
      - 'scripts/download-whisper-model.*'
      - 'scripts/download-sample-audio.*'
  workflow_dispatch:

permissions:
  pull-requests: write
  issues: write

env:
  OPENVINO_VERSION: "2025.3.0.0.dev20250805"

jobs:
  whisper-demo:
    name: Whisper Demo - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            runtime: linux-x64
          - os: windows-latest
            runtime: win-x64

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Cache Whisper Model
      uses: actions/cache@v4
      with:
        path: ./Models/whisper-tiny-int4-ov-npu
        key: whisper-model-v1
        restore-keys: |
          whisper-model-

    - name: Cache Sample Audio
      uses: actions/cache@v4
      with:
        path: ./samples/audio
        key: sample-audio-v1
        restore-keys: |
          sample-audio-

    - name: Restore dependencies
      run: dotnet restore OpenVINO.NET.sln

    - name: Download OpenVINO Runtime (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        ./scripts/download-openvino-runtime.ps1 -Version "${{ env.OPENVINO_VERSION }}" -OutputPath "build/native"
        
    - name: Set OPENVINO_RUNTIME_PATH for Windows
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        $runtimePath = "$(Get-Location)/build/native/runtimes/win-x64/native"
        "OPENVINO_RUNTIME_PATH=$runtimePath" | Out-File -FilePath $env:GITHUB_ENV -Append
        Write-Host "Set OPENVINO_RUNTIME_PATH to: $runtimePath"

    - name: Download OpenVINO Runtime (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        chmod +x scripts/download-openvino-runtime.sh
        ./scripts/download-openvino-runtime.sh "${{ env.OPENVINO_VERSION }}" "build/native" "24"
        
    - name: Set OPENVINO_RUNTIME_PATH for Linux
      if: matrix.os == 'ubuntu-latest'
      run: |
        RUNTIME_PATH="$(pwd)/build/native/runtimes/linux-x64/native"
        echo "OPENVINO_RUNTIME_PATH=$RUNTIME_PATH" >> $GITHUB_ENV
        echo "Set OPENVINO_RUNTIME_PATH to: $RUNTIME_PATH"

    - name: Download Whisper Model (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        ./scripts/download-whisper-model.ps1

    - name: Download Whisper Model (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        chmod +x scripts/download-whisper-model.sh
        ./scripts/download-whisper-model.sh

    - name: Download Sample Audio (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        if (Test-Path ./scripts/download-sample-audio.ps1) {
          ./scripts/download-sample-audio.ps1
        } else {
          Write-Host "Creating sample audio directory..."
          New-Item -ItemType Directory -Path "samples/audio" -Force
          
          # Download a simple test audio file
          $audioUrl = "https://sample-files.com/download/audio/wav/sample-3s.wav"
          $audioPath = "samples/audio/sample1.wav"
          
          try {
            Invoke-WebRequest -Uri $audioUrl -OutFile $audioPath -UseBasicParsing
            Write-Host "Downloaded sample audio to: $audioPath"
          } catch {
            Write-Host "Warning: Failed to download sample audio"
            # Create a dummy file for testing
            New-Item -ItemType File -Path $audioPath -Force
          }
        }

    - name: Download Sample Audio (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        if [ -f ./scripts/download-sample-audio.sh ]; then
          chmod +x ./scripts/download-sample-audio.sh
          ./scripts/download-sample-audio.sh
        else
          echo "Creating sample audio directory..."
          mkdir -p samples/audio
          
          # Download a simple test audio file
          AUDIO_URL="https://sample-files.com/download/audio/wav/sample-3s.wav"
          AUDIO_PATH="samples/audio/sample1.wav"
          
          if curl -L -o "$AUDIO_PATH" "$AUDIO_URL"; then
            echo "Downloaded sample audio to: $AUDIO_PATH"
          else
            echo "Warning: Failed to download sample audio"
            # Create a dummy file for testing
            touch "$AUDIO_PATH"
          fi
        fi

    - name: Build solution
      run: dotnet build OpenVINO.NET.sln --configuration Release

    - name: Set LD_LIBRARY_PATH for Linux
      if: matrix.os == 'ubuntu-latest'
      run: |
        LIBRARY_PATH="$(pwd)/build/native/runtimes/linux-x64/native"
        echo "LD_LIBRARY_PATH=$LIBRARY_PATH:$LD_LIBRARY_PATH" >> $GITHUB_ENV

    - name: Run WhisperDemo (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      timeout-minutes: 5
      run: |
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        
        # Get absolute paths
        $modelPath = "$(Get-Location)\Models\whisper-tiny-int4-ov-npu"
        $audioDir = "$(Get-Location)\samples\audio"
        
        # Set environment variable for model path
        $env:WHISPER_MODEL_PATH = $modelPath
        
        Write-Host "Model Path: $modelPath"
        Write-Host "Audio Dir: $audioDir"
        Write-Host "Checking if model exists..."
        if (Test-Path $modelPath) {
          Write-Host "Model directory found"
          Get-ChildItem $modelPath | Select-Object Name | Out-String | Write-Host
        } else {
          Write-Host "WARNING: Model directory not found at $modelPath"
        }
        
        # Navigate to WhisperDemo for binary output
        Set-Location samples\WhisperDemo
        
        $output = @()
        $output += "# Whisper Sample App Results - Windows x64"
        $output += ""
        $output += "**Generated:** $timestamp"
        $output += "**Platform:** win-x64"
        $output += "**Model:** whisper-tiny-int4-ov-npu"
        $output += ""
        
        # Check if we have audio files
        $audioFiles = Get-ChildItem -Path $audioDir -Filter "*.wav" -ErrorAction SilentlyContinue
        
        if ($audioFiles) {
          $output += "## Transcription Results"
          $output += ""
          Write-Host "Found $($audioFiles.Count) audio files"
          
          foreach ($audio in $audioFiles) {
            Write-Host "Processing: $($audio.Name)"
            $output += "### $($audio.Name)"
            $output += "``````"
            
            try {
              # Use Start-Process with timeout to prevent hanging
              $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release", "--", "--audio", "`"$($audio.FullName)`"", "--device", "CPU" -NoNewWindow -Wait -PassThru -RedirectStandardOutput "temp_output.txt" -RedirectStandardError "temp_error.txt"
              
              # Wait max 30 seconds per file
              if (!$process.WaitForExit(30000)) {
                $process.Kill()
                $output += "Error: Process timed out after 30 seconds"
              } else {
                $stdout = Get-Content "temp_output.txt" -Raw -ErrorAction SilentlyContinue
                $stderr = Get-Content "temp_error.txt" -Raw -ErrorAction SilentlyContinue
                if ($stdout) { $output += $stdout }
                if ($stderr) { $output += "STDERR: $stderr" }
              }
              
              Remove-Item "temp_output.txt", "temp_error.txt" -ErrorAction SilentlyContinue
            } catch {
              $output += "Error: $($_.Exception.Message)"
            }
            
            $output += "``````"
            $output += ""
          }
        } else {
          $output += "## Test Run"
          $output += "``````"
          Write-Host "No audio files found, running with generated test audio"
          
          # Run with generated test audio and timeout
          try {
            $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release", "--", "--device", "CPU", "--workflow" -NoNewWindow -Wait -PassThru -RedirectStandardOutput "temp_output.txt" -RedirectStandardError "temp_error.txt"
            
            if (!$process.WaitForExit(30000)) {
              $process.Kill()
              $output += "Error: Process timed out after 30 seconds"
            } else {
              $stdout = Get-Content "temp_output.txt" -Raw -ErrorAction SilentlyContinue
              $stderr = Get-Content "temp_error.txt" -Raw -ErrorAction SilentlyContinue
              if ($stdout) { $output += $stdout }
              if ($stderr) { $output += "STDERR: $stderr" }
            }
            
            Remove-Item "temp_output.txt", "temp_error.txt" -ErrorAction SilentlyContinue
          } catch {
            $output += "Error: $($_.Exception.Message)"
          }
          
          $output += "``````"
        }
        
        # Save and display output
        $output | Out-File -FilePath "whisper-results.md" -Encoding UTF8
        Write-Host "`n=== Results ===`n"
        Get-Content "whisper-results.md" | Write-Host
        Write-Host "`n=== End Results ===`n"

    - name: Run WhisperDemo (Linux)
      if: matrix.os == 'ubuntu-latest'
      timeout-minutes: 5
      run: |
        TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
        
        # Get absolute paths
        MODEL_PATH="$(pwd)/Models/whisper-tiny-int4-ov-npu"
        AUDIO_DIR="$(pwd)/samples/audio"
        
        # Set up library path
        export LD_LIBRARY_PATH="$(pwd)/build/native/runtimes/linux-x64/native:$LD_LIBRARY_PATH"
        
        echo "Model Path: $MODEL_PATH"
        echo "Audio Dir: $AUDIO_DIR"
        echo "LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
        echo "Checking if model exists..."
        if [ -d "$MODEL_PATH" ]; then
          echo "Model directory found"
          ls -la "$MODEL_PATH" | head -20
        else
          echo "WARNING: Model directory not found at $MODEL_PATH"
        fi
        
        # Navigate to WhisperDemo for binary output
        cd samples/WhisperDemo
        
        {
          echo "# Whisper Sample App Results - Linux x64"
          echo ""
          echo "**Generated:** $TIMESTAMP"
          echo "**Platform:** linux-x64"
          echo "**Model:** whisper-tiny-int4-ov-npu"
          echo ""
          
          # Check if we have audio files
          if ls "$AUDIO_DIR"/*.wav 2>/dev/null; then
            echo "## Transcription Results"
            echo ""
            
            AUDIO_COUNT=$(ls -1 "$AUDIO_DIR"/*.wav 2>/dev/null | wc -l)
            echo "Found $AUDIO_COUNT audio files" >&2
            
            for audio in "$AUDIO_DIR"/*.wav; do
              echo "Processing: $(basename "$audio")" >&2
              echo "### $(basename "$audio")"
              echo '```'
              # Use timeout to prevent hanging
              WHISPER_MODEL_PATH="$MODEL_PATH" timeout 30 dotnet run --configuration Release -- --audio "$audio" --device CPU 2>&1 || {
                EXIT_CODE=$?
                if [ $EXIT_CODE -eq 124 ]; then
                  echo "Error: Process timed out after 30 seconds"
                else
                  echo "Error running transcription (exit code: $EXIT_CODE)"
                fi
              }
              echo '```'
              echo ""
            done
          else
            echo "## Test Run"
            echo '```'
            echo "No audio files found, running with generated test audio" >&2
            # Run with generated test audio and workflow flag
            WHISPER_MODEL_PATH="$MODEL_PATH" timeout 30 dotnet run --configuration Release -- --device CPU --workflow 2>&1 || {
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 124 ]; then
                echo "Error: Process timed out after 30 seconds"
              else
                echo "Error running demo (exit code: $EXIT_CODE)"
              fi
            }
            echo '```'
          fi
        } > whisper-results.md
        
        echo ""
        echo "=== Results ==="
        cat whisper-results.md
        echo "=== End Results ==="
        echo ""

    - name: Upload Results
      uses: actions/upload-artifact@v4
      with:
        name: whisper-results-${{ matrix.runtime }}
        path: ./samples/WhisperDemo/whisper-results.md

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const resultsPath = './samples/WhisperDemo/whisper-results.md';
          
          if (fs.existsSync(resultsPath)) {
            const results = fs.readFileSync(resultsPath, 'utf8');
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const platform = '${{ matrix.runtime }}';
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes(`Whisper Sample App Results - ${platform === 'win-x64' ? 'Windows' : 'Linux'} x64`)
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: results
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: results
              });
            }
          }