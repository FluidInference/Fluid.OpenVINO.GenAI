name: Run Whisper Sample App

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'samples/WhisperDemo/**'
      - '.github/workflows/whisper-sample-app.yml'
      - 'scripts/download-whisper-model.*'
      - 'scripts/download-sample-audio.*'
  workflow_dispatch:

permissions:
  pull-requests: write
  issues: write

env:
  OPENVINO_VERSION: "2025.3.0.0.dev20250805"

jobs:
  whisper-demo:
    name: Whisper Demo
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Install Visual C++ Redistributables
      shell: pwsh
      run: |
        Write-Host "Installing Visual C++ Redistributables..."
        
        # Download and install VC++ redistributables
        $vcRedistUrl = "https://aka.ms/vs/17/release/vc_redist.x64.exe"
        $vcRedistPath = "vc_redist.x64.exe"
        
        try {
          Invoke-WebRequest -Uri $vcRedistUrl -OutFile $vcRedistPath
          
          # Install silently
          Start-Process -FilePath $vcRedistPath -ArgumentList "/install", "/quiet", "/norestart" -Wait
          
          Write-Host "✓ Visual C++ Redistributables installed successfully"
        } catch {
          Write-Host "Warning: Failed to install Visual C++ Redistributables: $($_.Exception.Message)"
          Write-Host "This may cause native library loading issues"
        } finally {
          if (Test-Path $vcRedistPath) {
            Remove-Item $vcRedistPath -Force
          }
        }

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Cache Whisper Model
      uses: actions/cache@v4
      with:
        path: ./Models/whisper-tiny-int4-ov-npu
        key: whisper-model-v1
        restore-keys: |
          whisper-model-

    - name: Cache Sample Audio
      uses: actions/cache@v4
      with:
        path: ./samples/audio
        key: sample-audio-v1
        restore-keys: |
          sample-audio-

    - name: Restore dependencies
      run: dotnet restore OpenVINO.NET.sln

    - name: Cache OpenVINO Runtime
      id: cache-openvino-windows
      uses: actions/cache@v4
      with:
        path: build/native/runtimes/win-x64/native
        key: openvino-runtime-windows-${{ env.OPENVINO_VERSION }}

    - name: Download OpenVINO Runtime
      if: steps.cache-openvino-windows.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        ./scripts/download-openvino-runtime.ps1 -Version "${{ env.OPENVINO_VERSION }}" -OutputPath "build/native"
        
    - name: Set OPENVINO_RUNTIME_PATH
      shell: pwsh
      run: |
        $runtimePath = "$(Get-Location)/build/native/runtimes/win-x64/native"
        "OPENVINO_RUNTIME_PATH=$runtimePath" | Out-File -FilePath $env:GITHUB_ENV -Append
        Write-Host "Set OPENVINO_RUNTIME_PATH to: $runtimePath"

    - name: Verify OpenVINO Runtime Installation
      shell: pwsh
      run: |
        Write-Host "Verifying OpenVINO Runtime Installation..."
        Write-Host "========================================"
        
        $runtimePath = "build/native/runtimes/win-x64/native"
        
        if (Test-Path $runtimePath) {
          Write-Host "✓ Runtime directory exists: $runtimePath"
          
          # List all files in the runtime directory
          Write-Host ""
          Write-Host "Files in runtime directory:"
          Get-ChildItem -Path $runtimePath -Recurse | Format-Table Name, Length, LastWriteTime
          
          # Check for specific required DLLs
          $requiredDlls = @("openvino_genai_c.dll", "openvino_c.dll")
          $missingDlls = @()
          
          foreach ($dll in $requiredDlls) {
            $found = Get-ChildItem -Path $runtimePath -Filter $dll -Recurse -ErrorAction SilentlyContinue
            if ($found) {
              Write-Host "✓ Found required DLL: $dll at $($found[0].FullName)"
            } else {
              Write-Host "✗ Missing required DLL: $dll"
              $missingDlls += $dll
            }
          }
          
          if ($missingDlls.Count -eq 0) {
            Write-Host ""
            Write-Host "✓ All required DLLs are present"
          } else {
            Write-Host ""
            Write-Host "❌ Missing DLLs: $($missingDlls -join ', ')"
            Write-Host "This will cause runtime failures"
            exit 1
          }
        } else {
          Write-Host "❌ Runtime directory not found: $runtimePath"
          exit 1
        }

    - name: Download Whisper Model
      shell: pwsh
      run: |
        ./scripts/download-whisper-model.ps1

    - name: Download Sample Audio
      shell: pwsh
      run: |
        if (Test-Path ./scripts/download-sample-audio.ps1) {
          ./scripts/download-sample-audio.ps1
        } else {
          Write-Host "Creating sample audio directory..."
          New-Item -ItemType Directory -Path "samples/audio" -Force
          
          # Download audio files from Hugging Face FluidInference/audio dataset
          $audioFiles = @(
            @{
              url = "https://huggingface.co/datasets/FluidInference/audio/resolve/main/glm.wav"
              filename = "glm.wav"
            },
            @{
              url = "https://huggingface.co/datasets/FluidInference/audio/resolve/main/startup.wav"
              filename = "startup.wav"
            }
          )
          
          foreach ($audio in $audioFiles) {
            $audioPath = "samples/audio/$($audio.filename)"
            Write-Host "Downloading $($audio.filename)..."
            
            try {
              Invoke-WebRequest -Uri $audio.url -OutFile $audioPath -UseBasicParsing
              Write-Host "✓ Downloaded $($audio.filename) to: $audioPath"
            } catch {
              Write-Host "Warning: Failed to download $($audio.filename): $($_.Exception.Message)"
              # Create a dummy file for testing
              New-Item -ItemType File -Path $audioPath -Force
            }
          }
        }

    - name: Build solution
      run: dotnet build OpenVINO.NET.sln --configuration Release

    - name: Setup Environment for OpenVINO
      shell: pwsh
      run: |
        # Set the OpenVINO runtime path - this is where the DLLs are actually located
        $runtimePath = "$(Get-Location)/build/native/runtimes/win-x64/native"
        
        # Set OPENVINO_RUNTIME_PATH environment variable (prioritized by NativeLibraryLoader)
        "OPENVINO_RUNTIME_PATH=$runtimePath" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Also add to PATH for compatibility
        $currentPath = $env:PATH
        $newPath = "$runtimePath;$currentPath"
        "PATH=$newPath" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        Write-Host "Set OPENVINO_RUNTIME_PATH to: $runtimePath"
        Write-Host "Added OpenVINO runtime to PATH: $runtimePath"
        Write-Host "Verifying PATH update..."
        Write-Host "PATH now contains:"
        ($newPath -split ';') | ForEach-Object { Write-Host "  $_" }

    - name: Run WhisperDemo
      shell: pwsh
      timeout-minutes: 5
      run: |
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        
        # Get absolute paths
        $modelPath = "$(Get-Location)\Models\whisper-tiny-int4-ov-npu"
        $audioDir = "$(Get-Location)\samples\audio"
        
        # Set environment variable for model path
        $env:WHISPER_MODEL_PATH = $modelPath
        
        Write-Host "Model Path: $modelPath"
        Write-Host "Audio Dir: $audioDir"
        Write-Host "Checking if model exists..."
        if (Test-Path $modelPath) {
          Write-Host "Model directory found"
          Get-ChildItem $modelPath | Select-Object Name | Out-String | Write-Host
        } else {
          Write-Host "WARNING: Model directory not found at $modelPath"
        }
        
        # Navigate to WhisperDemo for binary output
        Set-Location samples\WhisperDemo
        
        $output = @()
        $output += "# Whisper Sample App Results - Windows x64"
        $output += ""
        $output += "**Generated:** $timestamp"
        $output += "**Platform:** win-x64"
        $output += "**Model:** whisper-tiny-int4-ov-npu"
        $output += ""
        
        # Check if we have audio files
        $audioFiles = Get-ChildItem -Path $audioDir -Filter "*.wav" -ErrorAction SilentlyContinue
        
        if ($audioFiles) {
          $output += "## Transcription Results"
          $output += ""
          Write-Host "Found $($audioFiles.Count) audio files"
          
          foreach ($audio in $audioFiles) {
            Write-Host "Processing: $($audio.Name)"
            $output += "### $($audio.Name)"
            $output += "``````"
            
            try {
              # Use Start-Process with timeout to prevent hanging
              $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release", "--", "--audio", "`"$($audio.FullName)`"", "--device", "CPU" -NoNewWindow -Wait -PassThru -RedirectStandardOutput "temp_output.txt" -RedirectStandardError "temp_error.txt"
              
              # Wait max 30 seconds per file
              if (!$process.WaitForExit(30000)) {
                $process.Kill()
                $output += "Error: Process timed out after 30 seconds"
              } else {
                $stdout = Get-Content "temp_output.txt" -Raw -ErrorAction SilentlyContinue
                $stderr = Get-Content "temp_error.txt" -Raw -ErrorAction SilentlyContinue
                if ($stdout) { $output += $stdout }
                if ($stderr) { $output += "STDERR: $stderr" }
              }
              
              Remove-Item "temp_output.txt", "temp_error.txt" -ErrorAction SilentlyContinue
            } catch {
              $output += "Error: $($_.Exception.Message)"
            }
            
            $output += "``````"
            $output += ""
          }
        } else {
          $output += "## Test Run"
          $output += "``````"
          Write-Host "No audio files found, running with generated test audio"
          
          # Run with generated test audio and timeout
          try {
            $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release", "--", "--device", "CPU", "--workflow" -NoNewWindow -Wait -PassThru -RedirectStandardOutput "temp_output.txt" -RedirectStandardError "temp_error.txt"
            
            if (!$process.WaitForExit(30000)) {
              $process.Kill()
              $output += "Error: Process timed out after 30 seconds"
            } else {
              $stdout = Get-Content "temp_output.txt" -Raw -ErrorAction SilentlyContinue
              $stderr = Get-Content "temp_error.txt" -Raw -ErrorAction SilentlyContinue
              if ($stdout) { $output += $stdout }
              if ($stderr) { $output += "STDERR: $stderr" }
            }
            
            Remove-Item "temp_output.txt", "temp_error.txt" -ErrorAction SilentlyContinue
          } catch {
            $output += "Error: $($_.Exception.Message)"
          }
          
          $output += "``````"
        }
        
        # Save and display output
        $output | Out-File -FilePath "whisper-results.md" -Encoding UTF8
        Write-Host "`n=== Results ===`n"
        Get-Content "whisper-results.md" | Write-Host
        Write-Host "`n=== End Results ===`n"

    - name: Upload Results
      uses: actions/upload-artifact@v4
      with:
        name: whisper-results-win-x64
        path: ./samples/WhisperDemo/whisper-results.md

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const resultsPath = './samples/WhisperDemo/whisper-results.md';
          
          if (fs.existsSync(resultsPath)) {
            const results = fs.readFileSync(resultsPath, 'utf8');
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Whisper Sample App Results - Windows x64')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: results
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: results
              });
            }
          }