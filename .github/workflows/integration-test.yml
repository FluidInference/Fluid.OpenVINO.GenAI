name: Integration Test

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      test_devices:
        description: 'Devices to test (comma-separated: CPU,GPU,NPU)'
        required: false
        default: 'CPU,GPU,NPU'
        type: string
      model_name:
        description: 'Model to use for testing'
        required: false
        default: 'FluidInference/qwen3-0.6b-int4-ov-npu'
        type: string

jobs:
  integration-test:
    name: Integration Test
    runs-on: ${{ matrix.os }}
    env:
      OPENVINO_VERSION: "2025.2.0.0"
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            runtime: linux-x64
            shell: bash
          - os: windows-latest
            runtime: win-x64
            shell: pwsh

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Cache Model
      uses: actions/cache@v4
      with:
        path: ./Models
        key: model-${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}-v1
        restore-keys: |
          model-${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}-

    - name: Restore dependencies
      run: dotnet restore OpenVINO.NET.sln

    - name: Cache OpenVINO Runtime (Windows)
      if: matrix.os == 'windows-latest'
      id: cache-openvino-windows
      uses: actions/cache@v4
      with:
        path: build/native/openvino_genai_windows_${{ env.OPENVINO_VERSION }}_x86_64
        key: openvino-runtime-windows-${{ env.OPENVINO_VERSION }}

    - name: Download OpenVINO Runtime (Windows)
      if: matrix.os == 'windows-latest' && steps.cache-openvino-windows.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        Write-Host "Downloading OpenVINO GenAI Runtime for Windows..."
        
        # Try multiple potential URLs for robustness
        $urls = @(
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/windows/openvino_genai_windows_${{ env.OPENVINO_VERSION }}_x86_64.zip",
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/windows/openvino_genai_runtime_windows_${{ env.OPENVINO_VERSION }}_x86_64.zip"
        )
        
        $downloaded = $false
        $output = "openvino_genai_runtime.zip"
        
        foreach ($url in $urls) {
          Write-Host "Trying: $url"
          try {
            Invoke-WebRequest -Uri $url -OutFile $output -UserAgent "OpenVINO.NET/1.0"
            
            # Verify the downloaded file is a valid ZIP
            if (Test-Path $output -PathType Leaf) {
              $fileInfo = Get-Item $output
              if ($fileInfo.Length -gt 1MB) {
                Write-Host "✓ Successfully downloaded from: $url"
                $downloaded = $true
                break
              } else {
                Write-Host "✗ Downloaded file too small: $($fileInfo.Length) bytes"
                Remove-Item $output -ErrorAction SilentlyContinue
              }
            }
          } catch {
            Write-Host "✗ Failed to download from: $url - $($_.Exception.Message)"
            Remove-Item $output -ErrorAction SilentlyContinue
          }
        }
        
        if (-not $downloaded) {
          Write-Host "❌ Failed to download OpenVINO runtime from any URL"
          exit 1
        }
        
        Write-Host "Extracting runtime..."
        Expand-Archive -Path $output -DestinationPath "temp_extract" -Force
        
        # Find the extracted directory (handle different naming conventions)
        $extractedDirs = Get-ChildItem -Path "temp_extract" -Directory | Where-Object { $_.Name -like "openvino_genai*" }
        
        if ($extractedDirs.Count -eq 0) {
          Write-Host "❌ Could not find extracted OpenVINO directory"
          Get-ChildItem -Path "temp_extract" | Format-Table
          exit 1
        }
        
        $extractedDir = $extractedDirs[0].FullName
        Write-Host "Found extracted directory: $($extractedDirs[0].Name)"
        
        # Create target directory and copy files
        New-Item -Path "build/native/runtimes/win-x64/native" -ItemType Directory -Force
        
        # Try different potential library paths
        if (Test-Path "$extractedDir/runtime/bin") {
          Copy-Item -Path "$extractedDir/runtime/bin/*" -Destination "build/native/runtimes/win-x64/native/" -Recurse -Force
        } elseif (Test-Path "$extractedDir/bin") {
          Copy-Item -Path "$extractedDir/bin/*" -Destination "build/native/runtimes/win-x64/native/" -Recurse -Force
        } else {
          Write-Host "❌ Could not find binary directory in extracted folder"
          Get-ChildItem -Path $extractedDir | Format-Table
          exit 1
        }
        
        Remove-Item -Path $output, "temp_extract" -Recurse -Force
        Write-Host "✓ OpenVINO runtime setup completed"


    - name: Cache OpenVINO Runtime (Linux)
      if: matrix.os == 'ubuntu-latest'
      id: cache-openvino-linux
      uses: actions/cache@v4
      with:
        path: build/native/runtimes/linux-x64/native
        key: openvino-runtime-linux-${{ env.OPENVINO_VERSION }}

    - name: Download OpenVINO Runtime (Linux)
      if: matrix.os == 'ubuntu-latest' && steps.cache-openvino-linux.outputs.cache-hit != 'true'
      run: |
        echo "Downloading OpenVINO GenAI Runtime for Linux..."
        
        # Try multiple potential URLs for robustness
        urls=(
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/linux/openvino_genai_ubuntu24_${{ env.OPENVINO_VERSION }}_x86_64.tar.gz"
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/linux/openvino_genai_ubuntu22_${{ env.OPENVINO_VERSION }}_x86_64.tar.gz"
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/linux/openvino_genai_ubuntu20_${{ env.OPENVINO_VERSION }}_x86_64.tar.gz"
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/linux/openvino_genai_runtime_ubuntu24_${{ env.OPENVINO_VERSION }}_x86_64.tar.gz"
        )
        
        downloaded=false
        for url in "${urls[@]}"; do
          echo "Trying: $url"
          if wget -q --user-agent="OpenVINO.NET/1.0" -O openvino_genai_runtime.tar.gz "$url"; then
            # Verify the downloaded file is valid
            if file openvino_genai_runtime.tar.gz | grep -q "gzip compressed"; then
              echo "✓ Successfully downloaded from: $url"
              downloaded=true
              break
            else
              echo "✗ Invalid file format from: $url"
              rm -f openvino_genai_runtime.tar.gz
            fi
          else
            echo "✗ Failed to download from: $url"
          fi
        done
        
        if [ "$downloaded" = false ]; then
          echo "❌ Failed to download OpenVINO runtime from any URL"
          exit 1
        fi
        
        echo "Extracting runtime..."
        tar -xzf openvino_genai_runtime.tar.gz
        
        # Find the extracted directory (handle different naming conventions)
        extracted_dir=""
        for dir in openvino_genai_*; do
          if [ -d "$dir" ]; then
            extracted_dir="$dir"
            break
          fi
        done
        
        if [ -z "$extracted_dir" ]; then
          echo "❌ Could not find extracted OpenVINO directory"
          ls -la
          exit 1
        fi
        
        echo "Found extracted directory: $extracted_dir"
        
        # Create target directory and copy files preserving symlinks
        mkdir -p build/native/runtimes/linux-x64/native
        
        # Try different potential library paths
        if [ -d "$extracted_dir/runtime/lib/intel64" ]; then
          cp -a "$extracted_dir/runtime/lib/intel64/"* build/native/runtimes/linux-x64/native/
        elif [ -d "$extracted_dir/lib" ]; then
          cp -a "$extracted_dir/lib/"* build/native/runtimes/linux-x64/native/
        else
          echo "❌ Could not find library directory in $extracted_dir"
          ls -la "$extracted_dir"
          exit 1
        fi
        
        rm -rf openvino_genai_runtime.tar.gz "$extracted_dir"
        echo "✓ OpenVINO runtime setup completed"

    - name: Build solution
      run: dotnet build OpenVINO.NET.sln --configuration Release

    - name: Download Test Model
      working-directory: ./samples/QuickDemo
      run: |
        mkdir -p Models
        cd Models
        
        # Use model name from input or default
        MODEL_NAME="${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}"
        MODEL_DIR=$(echo "$MODEL_NAME" | cut -d'/' -f2)
        
        if [ ! -d "$MODEL_DIR" ] || [ ! -f "$MODEL_DIR/openvino_model.xml" ]; then
          echo "Downloading model: $MODEL_NAME"
          
          mkdir -p "$MODEL_DIR"
          cd "$MODEL_DIR"
          
          # Download key files
          for file in openvino_model.xml openvino_model.bin openvino_tokenizer.xml openvino_tokenizer.bin openvino_detokenizer.xml openvino_detokenizer.bin config.json generation_config.json; do
            echo "Downloading $file..."
            curl -L -f -o "$file" "https://huggingface.co/$MODEL_NAME/resolve/main/$file" --user-agent "OpenVINO.NET/1.0" || echo "Warning: Failed to download $file (may be optional)"
          done
          
          cd ..
          echo "✓ Model download completed"
        else
          echo "✓ Model already cached"
        fi
      shell: bash

    - name: Set Model Path Environment
      run: |
        MODEL_NAME="${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}"
        MODEL_DIR=$(echo "$MODEL_NAME" | cut -d'/' -f2)
        MODEL_PATH="$(pwd)/samples/QuickDemo/Models/$MODEL_DIR"
        echo "QUICKDEMO_MODEL_PATH=$MODEL_PATH" >> $GITHUB_ENV
      shell: bash

    - name: Run Integration Tests
      run: dotnet test tests/OpenVINO.NET.GenAI.Tests/OpenVINO.NET.GenAI.Tests.csproj --configuration Release --verbosity normal --filter "Category=Integration"

    - name: Test Device Functionality (Windows)
      if: matrix.os == 'windows-latest'
      working-directory: ./samples/QuickDemo
      shell: pwsh
      run: |
        $devices = "${{ inputs.test_devices || 'CPU,GPU,NPU' }}" -split ','
        $results = @()
        
        foreach ($device in $devices) {
          $device = $device.Trim()
          Write-Host "Testing device: $device"
          
          try {
            $output = dotnet run --configuration Release -- --device $device 2>&1
            $exitCode = $LASTEXITCODE
            
            if ($exitCode -eq 0) {
              Write-Host "✓ $device: SUCCESS" -ForegroundColor Green
              $results += "$device=SUCCESS"
              
              # Extract performance metrics from output
              $tpsMatch = [regex]::Match($output, 'Performance:\s+(\d+\.\d+)\s+tokens/sec')
              $latencyMatch = [regex]::Match($output, 'First token:\s+(\d+)ms')
              
              if ($tpsMatch.Success) {
                $tps = $tpsMatch.Groups[1].Value
                Write-Host "  Tokens/sec: $tps"
                $results += "$device_TPS=$tps"
              }
              
              if ($latencyMatch.Success) {
                $latency = $latencyMatch.Groups[1].Value
                Write-Host "  First token latency: ${latency}ms"
                $results += "$device_LATENCY=$latency"
              }
            } else {
              Write-Host "✗ $device: FAILED" -ForegroundColor Red
              $results += "$device=FAILED"
              Write-Host "Error output: $output"
            }
          } catch {
            Write-Host "✗ $device: ERROR - $($_.Exception.Message)" -ForegroundColor Red
            $results += "$device=ERROR"
          }
          
          Write-Host ""
        }
        
        # Save results to file for artifact upload
        $results | Out-File -FilePath "device-test-results-${{ matrix.runtime }}.txt"
        
        Write-Host "Device Test Summary:"
        $results | ForEach-Object { Write-Host "  $_" }

    - name: Test Device Functionality (Linux)
      if: matrix.os == 'ubuntu-latest'
      working-directory: ./samples/QuickDemo
      shell: bash
      run: |
        IFS=',' read -ra devices <<< "${{ inputs.test_devices || 'CPU,GPU,NPU' }}"
        results=()
        
        for device in "${devices[@]}"; do
          device=$(echo "$device" | xargs)  # trim whitespace
          echo "Testing device: $device"
          
          if output=$(dotnet run --configuration Release -- --device "$device" 2>&1); then
            echo "✓ $device: SUCCESS"
            results+=("$device=SUCCESS")
            
            # Extract performance metrics from output
            if [[ $output =~ Performance:[[:space:]]+([0-9]+\.[0-9]+)[[:space:]]+tokens/sec ]]; then
              tps="${BASH_REMATCH[1]}"
              echo "  Tokens/sec: $tps"
              results+=("${device}_TPS=$tps")
            fi
            
            if [[ $output =~ First\ token:[[:space:]]+([0-9]+)ms ]]; then
              latency="${BASH_REMATCH[1]}"
              echo "  First token latency: ${latency}ms"
              results+=("${device}_LATENCY=$latency")
            fi
          else
            echo "✗ $device: FAILED"
            results+=("$device=FAILED")
            echo "Error output: $output"
          fi
          
          echo ""
        done
        
        # Save results to file for artifact upload
        printf '%s\n' "${results[@]}" > "device-test-results-${{ matrix.runtime }}.txt"
        
        echo "Device Test Summary:"
        printf '  %s\n' "${results[@]}"

    - name: Run Benchmark Test
      working-directory: ./samples/QuickDemo
      run: dotnet run --configuration Release -- --benchmark
      continue-on-error: true

    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: integration-test-results-${{ matrix.runtime }}
        path: |
          ./samples/QuickDemo/device-test-results-*.txt
          ./samples/QuickDemo/benchmark-results-*.json

    - name: Create Test Summary (Windows)
      if: always() && matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "## Integration Test Results (${{ matrix.runtime }})" > test-summary.md
        Write-Host "" >> test-summary.md
        
        if (Test-Path "./samples/QuickDemo/device-test-results-${{ matrix.runtime }}.txt") {
          $results = Get-Content "./samples/QuickDemo/device-test-results-${{ matrix.runtime }}.txt"
          Write-Host "### Device Test Results" >> test-summary.md
          Write-Host "" >> test-summary.md
          Write-Host "| Device | Status | TPS | Latency |" >> test-summary.md
          Write-Host "|--------|--------|-----|---------|" >> test-summary.md
          
          $deviceData = @{}
          foreach ($line in $results) {
            $parts = $line -split '='
            if ($parts.Count -eq 2) {
              $key = $parts[0]
              $value = $parts[1]
              
              if ($key -like "*_TPS") {
                $device = $key -replace "_TPS", ""
                if (!$deviceData[$device]) { $deviceData[$device] = @{} }
                $deviceData[$device]["TPS"] = $value
              } elseif ($key -like "*_LATENCY") {
                $device = $key -replace "_LATENCY", ""
                if (!$deviceData[$device]) { $deviceData[$device] = @{} }
                $deviceData[$device]["LATENCY"] = "${value}ms"
              } else {
                if (!$deviceData[$key]) { $deviceData[$key] = @{} }
                $deviceData[$key]["STATUS"] = $value
              }
            }
          }
          
          foreach ($device in $deviceData.Keys) {
            $status = $deviceData[$device]["STATUS"] ?? "UNKNOWN"
            $tps = $deviceData[$device]["TPS"] ?? "N/A"
            $latency = $deviceData[$device]["LATENCY"] ?? "N/A"
            Write-Host "| $device | $status | $tps | $latency |" >> test-summary.md
          }
        }
        
        Write-Host ""
        Get-Content test-summary.md

    - name: Create Test Summary (Linux)
      if: always() && matrix.os == 'ubuntu-latest'
      shell: bash
      run: |
        echo "## Integration Test Results (${{ matrix.runtime }})" > test-summary.md
        echo "" >> test-summary.md
        
        if [ -f "./samples/QuickDemo/device-test-results-${{ matrix.runtime }}.txt" ]; then
          echo "### Device Test Results" >> test-summary.md
          echo "" >> test-summary.md
          echo "| Device | Status | TPS | Latency |" >> test-summary.md
          echo "|--------|--------|-----|---------|" >> test-summary.md
          
          declare -A deviceData
          
          while IFS= read -r line; do
            if [[ $line == *"="* ]]; then
              key="${line%%=*}"
              value="${line#*=}"
              
              if [[ $key == *"_TPS" ]]; then
                device="${key%_TPS}"
                deviceData["${device}_TPS"]="$value"
              elif [[ $key == *"_LATENCY" ]]; then
                device="${key%_LATENCY}"
                deviceData["${device}_LATENCY"]="${value}ms"
              else
                deviceData["${key}_STATUS"]="$value"
              fi
            fi
          done < "./samples/QuickDemo/device-test-results-${{ matrix.runtime }}.txt"
          
          # Extract unique devices
          devices=()
          for key in "${!deviceData[@]}"; do
            if [[ $key == *"_STATUS" ]]; then
              device="${key%_STATUS}"
              devices+=("$device")
            fi
          done
          
          # Sort and deduplicate devices
          IFS=$'\n' devices=($(sort -u <<< "${devices[*]}"))
          
          for device in "${devices[@]}"; do
            status="${deviceData[${device}_STATUS]:-UNKNOWN}"
            tps="${deviceData[${device}_TPS]:-N/A}"
            latency="${deviceData[${device}_LATENCY]:-N/A}"
            echo "| $device | $status | $tps | $latency |" >> test-summary.md
          done
        fi
        
        echo ""
        cat test-summary.md
        
    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          if (fs.existsSync('test-summary.md')) {
            const summary = fs.readFileSync('test-summary.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          }
